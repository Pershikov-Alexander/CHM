#include <vector>
#include <algorithm>
#include <stdexcept>
#include <cmath>
#include <iostream>
#include <iomanip>

using namespace std;
class cubSpline {
private:
    vector<double> x;       
    vector<double> y;       
    vector<double> a, b, c, d; 

public:
    cubSpline(const vector<double>& x_data, const vector<double>& y_data)
        : x(x_data), y(y_data) {

        if (x.size() != y.size()) {
            throw invalid_argument("Размеры x и y должны совпадать");
        }
        if (x.size() < 2) {
            throw invalid_argument("Нужно как минимум 2 точки");
        }

        vector<size_t> indices(x.size());
        for (size_t i = 0; i < indices.size(); ++i) indices[i] = i;
        sort(indices.begin(), indices.end(),
            [&](size_t i, size_t j) { return x[i] < x[j]; });

        vector<double> sorted_x(x.size()), sorted_y(y.size());
        for (size_t i = 0; i < indices.size(); ++i) {
            sorted_x[i] = x[indices[i]];
            sorted_y[i] = y[indices[i]];
        }
        x = sorted_x;
        y = sorted_y;
        coef();
    }
    double interpolate(double x_point) const {
        size_t i = findInt(x_point);
        double dx = x_point - x[i];
        return a[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
    }

    double deriv(double x_point) const {
        size_t i = findInt(x_point);
        double dx = x_point - x[i];
        return b[i] + 2 * c[i] * dx + 3 * d[i] * dx * dx;
    }

    double secDeriv(double x_point) const {
        size_t i = findInt(x_point);
        double dx = x_point - x[i];
        return 2 * c[i] + 6 * d[i] * dx;
    }

    const vector<double>& getA() const { return a; }
    const vector<double>& getB() const { return b; }
    const vector<double>& getC() const { return c; }
    const vector<double>& getD() const { return d; }
    const vector<double>& getX() const { return x; }
    const vector<double>& getY() const { return y; }

private:
    void coef() {
        size_t n = x.size() - 1;
        a.resize(n);
        b.resize(n);
        c.resize(n + 1); 
        d.resize(n);
        vector<double> h(n);
        for (size_t i = 0; i < n; ++i) {
            h[i] = x[i + 1] - x[i];
            a[i] = y[i];
        }
        vector<double> alpha(n + 1, 0.0);
        vector<double> beta(n + 1, 0.0);
        vector<double> gamma(n + 1, 0.0);
        vector<double> delta(n + 1, 0.0);

        alpha[0] = 1.0;
        beta[0] = 0.0;
        delta[0] = 0.0;
        alpha[n] = 1.0;
        gamma[n] = 0.0;
        delta[n] = 0.0;

        for (size_t i = 1; i < n; ++i) {
            alpha[i] = 2.0 * (h[i - 1] + h[i]);
            beta[i] = h[i - 1];
            gamma[i] = h[i];
            delta[i] = 3.0 * ((y[i + 1] - y[i]) / h[i] - (y[i] - y[i - 1]) / h[i - 1]);
        }
        vector<double> P(n + 1, 0.0);
        vector<double> Q(n + 1, 0.0);

        P[0] = -beta[0] / alpha[0];
        Q[0] = delta[0] / alpha[0];

        for (size_t i = 1; i <= n; ++i) {
            double den = alpha[i] + gamma[i] * P[i - 1];
            P[i] = -beta[i] / den;
            Q[i] = (delta[i] - gamma[i] * Q[i - 1]) / den;
        }
        c[n] = Q[n];
        for (int i = n - 1; i >= 0; --i) {
            c[i] = P[i] * c[i + 1] + Q[i];
        }
        for (size_t i = 0; i < n; ++i) {
            b[i] = (y[i + 1] - y[i]) / h[i] - h[i] * (2.0 * c[i] + c[i + 1]) / 3.0;
            d[i] = (c[i + 1] - c[i]) / (3.0 * h[i]);
        }
    }

    size_t findInt(double x_point) const {
        if (x_point < x[0] || x_point > x.back()) {
            throw out_of_range("Точка находится вне диапазона интерполяции");
        }
        if (x_point == x.back()) {
            return x.size() - 2;
        }

        size_t left = 0;
        size_t right = x.size() - 1;

        while (left <= right) {
            size_t mid = left + (right - left) / 2;

            if (x[mid] <= x_point && x_point < x[mid + 1]) {
                return mid;
            }
            else if (x_point < x[mid]) {
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }

        return x.size() - 2;
    }
};

int main() {
    vector<double> x_data, y_data;
    setlocale(LC_ALL, "");

    int n;
    cout << "Введите количество точек: ";
    cin >> n;

    if (n < 2) {
        throw invalid_argument("Нужно как минимум 2 точки");
    }
    cout << "Ввод значений x\n";
        for (int i = 0; i < n; ++i) {
            double x;
            cout << "x[" << i << "] = ";
            cin >> x;
            x_data.push_back(x);
        }

        cout << "Ввод значений f(x)\n";
        for (int i = 0; i < n; ++i) {
            double y;
            cout << "f(" << x_data[i] << ") = ";
            cin >> y;
            y_data.push_back(y);
        }

        cubSpline spline(x_data, y_data);

        vector<double> res_points;
        int res_count;
        cout << "Введите количество точек для исследования: ";
        cin >> res_count;

        if (res_count <= 0) {
            throw invalid_argument("Количество точек должно быть положительным");
        }
        for (int i = 0; i < res_count; ++i) {
            double point;
            cout << "Точка " << i + 1 << ": ";
            cin >> point;
            res_points.push_back(point);
        }

        cout << endl << setw(12) << "x" << setw(16) << "f(x)"
            << setw(16) << "f'(x)" << setw(16) << "f''(x)" << "\n";
        cout << string(72, '-') << "\n";

        for (double x_point : res_points) {
            try {
                double y_point = spline.interpolate(x_point);
                double dy_point = spline.deriv(x_point);
                double d2y_point = spline.secDeriv(x_point);

                cout << setw(12) << fixed << setprecision(6) << x_point
                    << setw(16) << scientific << setprecision(6) << y_point
                    << setw(16) << scientific << setprecision(6) << dy_point
                    << setw(16) << scientific << setprecision(6) << d2y_point << "\n";
            }
            catch (const out_of_range& e) {
                cout << setw(12) << fixed << setprecision(6) << x_point
                    << "вне диапазона\n";
            }
        }

}
