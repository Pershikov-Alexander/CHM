#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <chrono>
#include <iomanip>
#include <fstream>

using namespace std;
const double PI = 3.14159265358979323846;

vector<complex<double>> DFT(const vector<complex<double>>& x) {
    int N = x.size();
    vector<complex<double>> X(N);
    for (int k = 0; k < N; ++k) {
        X[k] = 0;
        for (int n = 0; n < N; ++n) {
            double angle = -2 * PI * k * n / N;
            X[k] += x[n] * complex<double>(cos(angle), sin(angle));
        }
    }
    return X;
}

vector<complex<double>> IDFT(const vector<complex<double>>& X) {
    int N = X.size();
    vector<complex<double>> x(N);
    for (int n = 0; n < N; ++n) {
        x[n] = 0;
        for (int k = 0; k < N; ++k) {
            double angle = 2 * PI * k * n / N;
            x[n] += X[k] * complex<double>(cos(angle), sin(angle));
        }
        x[n] /= N;
    }
    return x;
}

int bitReverse(int x, int log2n) {
    int n = 0;
    for (int i = 0; i < log2n; ++i) {
        n <<= 1;
        n |= (x & 1);
        x >>= 1;
    }
    return n;
}

void bitReversePermute(vector<complex<double>>& a) {
    int n = a.size();
    int log2n = 0;
    while ((1 << log2n) < n) log2n++;
    for (int i = 0; i < n; ++i) {
        int rev = bitReverse(i, log2n);
        if (i < rev) swap(a[i], a[rev]);
    }
}

vector<complex<double>> FFT_iterative(vector<complex<double>> x) {
    int N = x.size();
    if ((N & (N - 1)) != 0) {
        cerr << "Длина должна быть степенью двойки" << endl;
        return {};
    }

    bitReversePermute(x);
    for (int len = 2; len <= N; len <<= 1) {
        double angle = -2 * PI / len;
        complex<double> wlen(cos(angle), sin(angle));
        for (int i = 0; i < N; i += len) {
            complex<double> w(1);
            for (int j = 0; j < len / 2; ++j) {
                complex<double> u = x[i + j];
                complex<double> v = w * x[i + j + len / 2];
                x[i + j] = u + v;
                x[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    return x;
}

vector<complex<double>> IFFT_iterative(vector<complex<double>> X) {
    int N = X.size();
    if ((N & (N - 1)) != 0) {
        cerr << "Длина должна быть степенью двойки" << endl;
        return {};
    }

    bitReversePermute(X);
    for (int len = 2; len <= N; len <<= 1) {
        double angle = 2 * PI / len;
        complex<double> wlen(cos(angle), sin(angle));
        for (int i = 0; i < N; i += len) {
            complex<double> w(1);
            for (int j = 0; j < len / 2; ++j) {
                complex<double> u = X[i + j];
                complex<double> v = w * X[i + j + len / 2];
                X[i + j] = u + v;
                X[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    for (auto& val : X) val /= N;
    return X;
}

vector<complex<double>> generateYourSignal(int N = 2048) {
    vector<complex<double>> signal(N);
    for (int j = 0; j < N; ++j) {
        double value = 2.18 * cos(2 * PI * 2 * j / N + PI / 6)
            + 0.21 * cos(2 * PI * 182 * j / N);
        signal[j] = complex<double>(value, 0);
    }
    return signal;
}

void printFrequency(const string& label, const vector<complex<double>>& spectrum, int m) {
    if (m < 0 || m >= (int)spectrum.size()) return;

    complex<double> X = spectrum[m];
    double magnitude = abs(X);
    double phase = arg(X);

    cout << label << " m=" << m << ": ";
    cout << "Rez=" << X.real() << " ";
    cout << "Imz=" << X.imag() << " ";
    cout << "|z|=" << magnitude << " ";
    cout << "фаза=" << phase << endl;
}

void printMainFrequencies(const string& label, const vector<complex<double>>& spectrum) {
    vector<int> main_freqs = { 2, 182, 2046, 1866 };

    cout << "\n" << label << " главные частоты:" << endl;
    for (int m : main_freqs) {
        if (m < (int)spectrum.size()) {
            printFrequency("", spectrum, m);
        }
    }
}

void saveSpectrumToFile(const vector<complex<double>>& spectrum, const string& filename) {
    ofstream file(filename);
    if (!file.is_open()) {
        cerr << "Ошибка открытия файла: " << filename << endl;
        return;
    }

    file << fixed << setprecision(12);

    for (int m = 0; m < (int)spectrum.size(); ++m) {
        file << m << " " << spectrum[m].real() << " " << spectrum[m].imag() << "\n";
    }

    file.close();
}

void saveSignalToFile(const vector<complex<double>>& signal, const string& filename) {
    ofstream file(filename);
    if (!file.is_open()) {
        cerr << "Ошибка открытия файла: " << filename << endl;
        return;
    }

    file << fixed << setprecision(12);

    for (int n = 0; n < (int)signal.size(); ++n) {
        file << n << " " << signal[n].real() << "\n";
    }

    file.close();
}

vector<complex<double>> filterHighFrequencies(const vector<complex<double>>& spectrum) {
    vector<complex<double>> filtered = spectrum;
    int N = filtered.size();

    vector<int> high_freqs = { 182, 1866 };
    for (int m : high_freqs) {
        if (m < N) {
            filtered[m] = complex<double>(0, 0);
        }
    }

    return filtered;
}

int main() {
    setlocale(LC_ALL, "");

    int N = 2048;
    vector<complex<double>> signal = generateYourSignal(N);

    auto start = chrono::high_resolution_clock::now();
    vector<complex<double>> dft_spectrum = DFT(signal);
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double> dft_time = end - start;

    start = chrono::high_resolution_clock::now();
    vector<complex<double>> idft_reconstructed = IDFT(dft_spectrum);
    end = chrono::high_resolution_clock::now();
    chrono::duration<double> idft_time = end - start;

    start = chrono::high_resolution_clock::now();
    vector<complex<double>> fft_spectrum = FFT_iterative(signal);
    end = chrono::high_resolution_clock::now();
    chrono::duration<double> fft_time = end - start;

    start = chrono::high_resolution_clock::now();
    vector<complex<double>> ifft_reconstructed = IFFT_iterative(fft_spectrum);
    end = chrono::high_resolution_clock::now();
    chrono::duration<double> ifft_time = end - start;

    cout << "DFT время: " << dft_time.count() << " с" << endl;
    cout << "IDFT время: " << idft_time.count() << " с" << endl;
    cout << "FFT время: " << fft_time.count() << " с" << endl;
    cout << "IFFT время: " << ifft_time.count() << " с" << endl;

    printMainFrequencies("DFT", dft_spectrum);
    printMainFrequencies("FFT", fft_spectrum);

    saveSpectrumToFile(dft_spectrum, "dft_spectrum.txt");
    saveSignalToFile(idft_reconstructed, "idft_reconstructed.txt");

    vector<complex<double>> filtered_spectrum = filterHighFrequencies(dft_spectrum);

    saveSpectrumToFile(filtered_spectrum, "filtered_spectrum.txt");

    vector<complex<double>> filtered_signal = IDFT(filtered_spectrum);
    saveSignalToFile(filtered_signal, "filtered_signal.txt");

    cout << endl;

    int m;
    while (true) {
        cout << "Введите m (0-" << N - 1 << ", -1 для выхода): ";
        cin >> m;

        if (m == -1) break;
        if (m < 0 || m >= N) {
            cout << "Неверный ввод" << endl;
            continue;
        }

        cout << "DFT: ";
        printFrequency("", dft_spectrum, m);

        cout << "После фильтрации: ";
        printFrequency("", filtered_spectrum, m);


        complex<double> dft_val = dft_spectrum[m];
        complex<double> filtered_val = filtered_spectrum[m];
        double diff = abs(dft_val - filtered_val);
        cout << endl;
    }
}
